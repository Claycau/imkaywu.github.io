<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>The Journey Is the Reward</title>
 <link href="http://lhzhang.com/atom.xml" rel="self"/>
 <link href="http://lhzhang.com/"/>
 <updated>2013-11-23T15:12:02+08:00</updated>
 <id>http://lhzhang.com/</id>
 <author>
   <name>Linghua Zhang</name>
   <email>linghua.zhang@me.com</email>
 </author>

 
 <entry>
   <title>Transform to Time-series curve</title>
   <link href="http://lhzhang.com/2013/11/23/Transform-to-time-series-curve.html"/>
   <updated>2013-11-23T00:00:00+08:00</updated>
   <id>http://lhzhang.com/2013/11/23/Transform-to-time-series-curve</id>
   <content type="html">&lt;p&gt;After obtaining the contour vertex and the direction of hand, we can transform the contour vertex into a &lt;em&gt;time-series curve&lt;/em&gt;. The time-series curve records the relative distance between each contour vertex to the centroid starting from the reference point. The horizontal axis denotes the angle between each contour vertex and the reference point relative to the centroid, normalized by 360. The vertical axis denotes the Euclidean distance between the contour vertices and the centroid, normalized by the radius of the inscribed circle. Here is how it's done.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function [degree,norm_distance]=trans_graph1(x_array,y_array,x_center,y_center)
    length=find(x_array, 1, 'last');
    radius=atan2(y_array(1:length)-y_center,x_array(1:length)-x_center);
    degree=radius./pi*180;
    degree(degree&amp;gt;0)=360-degree(degree&amp;gt;0);    % -180~+180=&amp;gt;0~360
    degree(degree&amp;lt;0)=abs(degree(degree&amp;lt;0));
    degree=degree-degree(1);
    degree(degree&amp;gt;0)=360-degree(degree&amp;gt;0);
    degree(degree&amp;lt;0)=-degree(degree&amp;lt;0);
    degree=degree/360;

    x_distance=x_array-x_center;
    y_distance=y_array-y_center;
    distance=zeros(1,length);
    for i=1:length
        distance(i)=norm([x_distance(i),y_distance(i)]);
    end
    min_distance=min(distance);
    norm_distance=distance./min_distance;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;em&gt;time-series curve&lt;/em&gt; is used to find the positions of fingertips and fingervalleys for further determine the accurate direction of hand.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Find the position of fingertips and fingervalleys</title>
   <link href="http://lhzhang.com/2013/11/23/Find-the-fingertips-and-fingerroots.html"/>
   <updated>2013-11-23T00:00:00+08:00</updated>
   <id>http://lhzhang.com/2013/11/23/Find-the-fingertips-and-fingerroots</id>
   <content type="html">&lt;p&gt;After obtaining the &lt;em&gt;time-series curve&lt;/em&gt;, we can find the positions of the fingertips and fingerroots.&lt;/p&gt;

&lt;p&gt;I decided to find the lowest points between every two fingers and the ones at the start of the thumb and end of the little finger (I refer them as fingervalleys). How to do that? Well, I assume they are all the lowest points in the time-series curve. But this brings another issue, because there are many points thet are locally lowest, but they are not the points I was looking for. So in order to eliminate these error points, I assume that for every fingervalley, there is also a fingertip whose height should surpass a certain threshold.&lt;/p&gt;

&lt;p&gt;After the fingervalleys are detected, it's easy to detect the fingertip, you just have to find the highest points in the graph.&lt;/p&gt;

&lt;p&gt;After finding the fingertips, we need to locate the fingerroots for every finger (the points are the root of every finger). This is done by comparing the neighboring widths below every fingertip, if &gt; the latter width &gt;constant * the former width&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Find the direction of hand</title>
   <link href="http://lhzhang.com/2013/11/23/Find-the-direction-of-hand-gestures.html"/>
   <updated>2013-11-23T00:00:00+08:00</updated>
   <id>http://lhzhang.com/2013/11/23/Find-the-direction-of-hand-gestures</id>
   <content type="html">&lt;p&gt;After detecting the contour of the hand gestures, we represent it as a [time-series curce], as shown in the following images.&lt;/p&gt;

&lt;p&gt;The [time-series curve] records the relative distance between each contour vertex to the centroid starting from the reference point. The horizontal axis denotes the angle between each contour vertex and the reference point relative to the centroid, normalized by 360. The vertical axis denotes the Euclidean distance between the contour vertices and the centroid, normalized by the radius of the inscribed circle. So what we gonna do is finding this reference points and it has to be relatively fixed, otherwise the degree of the ensuing points may vary among different images. We choose to first detect the direction of the hand, then locate this reference point in the wrist area.&lt;/p&gt;

&lt;h3&gt;Plan A&lt;/h3&gt;

&lt;p&gt;Intuitively, the contour of hand represent the direction of the hand (though this is not accurate, it's suffice for right now), so we can check the neighboring contour vertex and their relative positions, then calculate the direction of hand using this information.&lt;/p&gt;

&lt;p&gt;I decide to predefine 16 different directions and here is how I did it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function direction_angle=direction_detector1(x_array,y_array)
direction=zeros(1,17);
for i=1:size(x_array,2);
    index1=i;
    if(i&amp;lt;size(x_array,2)-2)
        index2=i+3;
    elseif(i&amp;lt;size(x_array,2)-1)
        index2=1;
    elseif(i&amp;lt;size(x_array,2))
        index2=2;
    else
        index2=3;
    end
    if(x_array(index2)~=x_array(index1))
        k=(y_array(index2)-y_array(index1))/(x_array(index2)-x_array(index1));
        switch k
            case 0
                if(x_array(index2)&amp;gt;x_array(index1))
                    direction(1)=direction(1)+1;
                else
                    direction(17)=direction(17)+1;
                end
            case -1/3
                direction(2)=direction(2)+1;
            case -1/2
                direction(3)=direction(3)+1;
            case -2/3
                direction(4)=direction(4)+1;
            case -1
                direction(5)=direction(5)+1;
            case -3/2
                direction(6)=direction(6)+1;
            case -2
                direction(7)=direction(7)+1;
            case -3
                direction(8)=direction(8)+1;

            case 3
                direction(10)=direction(10)+1;
            case 2
                direction(11)=direction(11)+1;
            case 3/2
                direction(12)=direction(12)+1;
            case 1
                direction(13)=direction(13)+1;
            case 2/3
                direction(14)=direction(14)+1;
            case 1/2
                direction(15)=direction(15)+1;
            case 1/3
                direction(16)=direction(16)+1;
        end
    else
        direction(9)=direction(9)+1;
    end
end

angle=-[atan2(0,1),atan2(-1,3),atan2(-1,2),atan2(-2,3),atan2(-1,1),atan2(-3,2),atan2(-2,1),atan2(-3,1),atan2(-1,-0),atan2(-3,-1),atan2(-2,-1),atan2(-3,-2),atan2(-1,-1),atan2(-2,-3),atan2(-1,-2),atan2(-1,-3)]/pi*180;
direction_temp=zeros(1,15);
direction([1,17])=[];
angle(1)=[];
[a,index]=max(direction);
for i=1:15
    direction_temp(i)=i-index;
end
direction=direction/sum(direction);
direction=direction.*direction_temp;
direction=sum(direction);
index=find(direction_temp==0);
direction_fix=fix(direction);
if(direction&amp;lt;0)
    direction_angle=angle(index+direction_fix)-abs(direction-direction_fix)*(angle(index+direction_fix)-angle(index+direction_fix-1));
else
    direction_angle=abs(direction-direction_fix)*(angle(index+direction_fix+1)-angle(index+direction_fix))+angle(index+direction_fix);
end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to locate the reference point in the wrist.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function [x_refer,y_refer,index]=refer_point(x_array,y_array,x_center,y_center,direction_angle)
direction_angle1=atan2((y_array-y_center),(x_array-x_center))/pi*180;
direction_angle1(direction_angle1&amp;gt;0)=360-direction_angle1(direction_angle1&amp;gt;0);    % -180~+180=&amp;gt;0~360
direction_angle1(direction_angle1&amp;lt;0)=-direction_angle1(direction_angle1&amp;lt;0);
direction_angle1=direction_angle1-direction_angle-180;%this may have problems
while(true)
    [a,index]=min(abs(direction_angle1));
    x_refer=x_array(index);
    y_refer=y_array(index);
    if(y_refer&amp;gt;y_center)
        break;
    end
    direction_angle1(index)=360;
end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Plan B&lt;/h3&gt;

&lt;p&gt;This method mentioned above is not all that accurate, especially when the hands are tilted. So I came up with something more accurate. Because points below the centroid actually contribute less to the direction of hand, and even worse have nothing to do with the direction. Like the points in the wrist, they are almost perpendicular to the hand direction. So I only use those above the centroid to calculate the directione.&lt;/p&gt;

&lt;p&gt;First, I need to find out the points that are perpendicular to the direction detected initially.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function [start_index,end_index]=start_end_points(x_array,y_array,x_center,y_center,direction_angle)
flag1=1;
flag2=1;
direction_angle1=atan2((y_array-y_center),(x_array-x_center))/pi*180;
direction_angle1(direction_angle1&amp;gt;0)=360-direction_angle1(direction_angle1&amp;gt;0);    % -180~+180=&amp;gt;0~360
direction_angle1(direction_angle1&amp;lt;0)=-direction_angle1(direction_angle1&amp;lt;0);
direction_angle2=direction_angle1;
if(direction_angle&amp;lt;90)
    direction_angle1=direction_angle+270-direction_angle1;%end point,-90+360
else
    direction_angle1=direction_angle1-direction_angle+90;
end
direction_angle2=direction_angle2-direction_angle-90;%start point

while(true)
    [a,end_index]=min(abs(direction_angle1));
    [a,start_index]=min(abs(direction_angle2));
    if(x_array(end_index)&amp;gt;x_center)
        flag1=0;
    else
        direction_angle1(end_index)=360;
    end
    if(x_array(start_index)&amp;lt;x_center)
        flag2=0;
    else
        direction_angle2(start_index)=360;
    end
    if(~(flag1||flag2))
        break;
    end
end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, I transform the hand contour to a [time-series graph] to [find the fingertip and fingervalleys]. These positions of fingers are the key to find out the accurate positions of each finger, and we assume that the directions of the fingers represent the direction of the hand, thus the direction detected using this method is much more accurate and reliable.&lt;/p&gt;

&lt;p&gt;Here is the code to find the accurate direction of fingers and hand&lt;/p&gt;

&lt;p&gt;%% ----detect the direction again---- %%&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;direction=zeros(1,size(fingertip,2));
for i=1:2*size(fingertip,2)
    index=ceil(i/2);
    index1=mod(i,2);
    if(index1)
        finger_index=(start_index+fingertip(index)-1)-20;
        direction_temp=atan2(y_array(finger_index)-y_array(start_index+fingervalley(index)-1),x_array(finger_index)-x_array(start_index+fingervalley(index)-1))/pi*180;
    else
        finger_index=(start_index+fingertip(index)-1)+20;
        direction_temp=atan2(y_array(finger_index)-y_array(start_index+fingervalley(index+1)-1),x_array(finger_index)-x_array(start_index+fingervalley(index+1)-1))/pi*180;
    end
    direction_temp=(direction_temp&amp;lt;=0)*abs(direction_temp)+(direction_temp&amp;gt;0)*(360-direction_temp);
    direction_temp=(direction_temp&amp;gt;270)*(direction_temp-360)+(direction_temp&amp;lt;270)*direction_temp;
    direction(index)=direction(index)+direction_temp;
end
direction_angle1=mean(direction/2);
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Find the contour of the hand gestures</title>
   <link href="http://lhzhang.com/2013/11/23/Find-the-contour-of-the-hand-gestures.html"/>
   <updated>2013-11-23T00:00:00+08:00</updated>
   <id>http://lhzhang.com/2013/11/23/Find-the-contour-of-the-hand-gestures</id>
   <content type="html">&lt;p&gt;Our algorithm of hand gesture recognition begins with the detection of the hand contour and connect these points in a consecutive manner. This problem may sound intuitive and simple for human beings, when it comes to the computer, the issue is a little more complicated. Here is why, because the contour is no longer smooth as we expect it would be, possibility is high that we may run into a deadend before we reach the end point, then what we get is no long the whole but part of the hand contour. The contour detection algorithm should be able to ignore all the noise points.&lt;/p&gt;

&lt;p&gt;So what are exactly these noisy points we are talking about. Well, here are two images showing two typical scenarios. It's straightforward that when the computer runs into these points, it runs into a deadend.&lt;/p&gt;

&lt;p&gt;Here is my solution to this problem, it's quite clear these points have two neighboring points up and down/left and right that have different values from themselves (the points in the hand region is 1 while the points outside is 0). So we can use a variable called edge_direction to indicate where their neighboring points are (up-down/left-down). If the points in the hand have both neighboring up-down/left-down points, it's the '&lt;em&gt;deadend&lt;/em&gt;' points we are looking for.&lt;/p&gt;

&lt;p&gt;The above is just a simple depict of the hand contour detection algorithm, I think no other words are convincing than some codes, so check out my source code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function edge_map=edge_finder(binary_map,row,colum)
edge_map=zeros(size(binary_map));
edge_direction=zeros(size(binary_map));
for i=1:row
    j=1;
    while(true)
        if(j==colum+1)
            break;
        elseif(i~=1&amp;amp;&amp;amp;j~=1&amp;amp;&amp;amp;i~=row&amp;amp;&amp;amp;j~=colum)
            if(xor(binary_map(i,j),binary_map(i,j+1)))
                if(edge_map(i,j+binary_map(i,j+1))==1&amp;amp;&amp;amp;(edge_direction(i,j+binary_map(i,j+1))==1||edge_direction(i,j+binary_map(i,j+1))==3))%可以去除想101图中的孤立的竖线
                    edge_map(i,j+binary_map(i,j+1))=0;
                    edge_direction(i,j+binary_map(i,j+1))=0;
                    binary_map(i,j+binary_map(i,j+1))=0;
                    continue;
                else
                    edge_map(i,j+binary_map(i,j+1))=1;
                    edge_direction(i,j+binary_map(i,j+1))=edge_direction(i,j+binary_map(i,j+1))+1;
                end
            end
            if(xor(binary_map(i,j),binary_map(i+1,j)))
                if(edge_map(i+binary_map(i+1,j),j)==1&amp;amp;&amp;amp;(edge_direction(i+binary_map(i+1,j),j)==2||edge_direction(i+binary_map(i+1,j),j)==3))
                    edge_map(i+binary_map(i+1,j),j)=0;
                    binary_map(i+binary_map(i+1,j),j)=0;
                    if(binary_map(i+binary_map(i+1,j),j-1))
                        j=j-1;
                    end
                    edge_direction(i+binary_map(i+1,j),j)=0;
                    continue;
                else
                    edge_map(i+binary_map(i+1,j),j)=1;
                    edge_direction(i+binary_map(i+1,j),j)=edge_direction(i+binary_map(i+1,j),j)+2;
                end
            end
        else
            if(binary_map(i,j))
               edge_map(i,j)=1;
            end
        end
        j=j+1;
    end
end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here comes the codes to connect the contour points in a consecutive manner. We first consider the points in the neighborhood regions than that in the 8-neighborhood region.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function [x_array,y_array]=edge_connector(edge_map,row,colum)
edge_map(row+1,:)=0;
edge_map(:,colum+1)=0;
% [y_origin,x_origin]=ind2sub(size(edge_map),min(find(edge_map)));
[y_index,x_index]=find(edge_map==1);
[y_origin,index]=max(y_index);
x_origin=min(x_index(index));
x_array=zeros(1,sum(sum(edge_map)));
y_array=zeros(1,sum(sum(edge_map)));
x_array(1)=x_origin;
y_array(1)=y_origin;
i=1;

while(1)
    x_present=x_array(i);
    y_present=y_array(i);
    i=i+1;
    if(sum(sum(edge_map(y_present-1:y_present,x_present-1:x_present)))&amp;gt;1)%top left direction
        if(edge_map(y_present-1,x_present))%top
            x_array(i)=x_present;
            y_array(i)=y_present-1;
        elseif(edge_map(y_present,x_present-1))%left
            x_array(i)=x_present-1;
            y_array(i)=y_present;
        else%top_left
            x_array(i)=x_present-1;
            y_array(i)=y_present-1;
        end
    elseif(sum(sum(edge_map(y_present-1:y_present,x_present:x_present+1)))&amp;gt;1)%top right direction
        if(edge_map(y_present-1,x_present))%top
            x_array(i)=x_present;
            y_array(i)=y_present-1;
        elseif(edge_map(y_present,x_present+1))%right
            x_array(i)=x_present+1;
            y_array(i)=y_present;
        else%top_right
            x_array(i)=x_present+1;
            y_array(i)=y_present-1;
        end
    elseif(sum(sum(edge_map(y_present:y_present+1,x_present:x_present+1)))&amp;gt;1)%bottom_right direction
        if(edge_map(y_present+1,x_present))%bottom
            x_array(i)=x_present;
            y_array(i)=y_present+1;
        elseif(edge_map(y_present,x_present+1))%right
            x_array(i)=x_present+1;
            y_array(i)=y_present;
        else%bottom_right
            x_array(i)=x_present+1;
            y_array(i)=y_present+1;
        end
    elseif(sum(sum(edge_map(y_present:y_present+1,x_present-1:x_present)))&amp;gt;1)%bottom_left direction
        if(edge_map(y_present+1,x_present))%bottom
            x_array(i)=x_present;
            y_array(i)=y_present+1;
        elseif(edge_map(y_present,x_present-1))%left
            x_array(i)=x_present-1;
            y_array(i)=y_present;
        else%bottom_left
            x_array(i)=x_present-1;
            y_array(i)=y_present+1;
        end
    else
        break;
    end
    edge_map(y_present,x_present)=0;
end
x_array(x_array==0)=[];
y_array(y_array==0)=[];
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So this the the result of our algorithm, and we've tested it on 200+ images and we will take more pictures to test the robustness of the algorithm.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Find the centroid of the hand gestures</title>
   <link href="http://lhzhang.com/2013/11/23/Find-the-centroid-of-the-hand-gestures.html"/>
   <updated>2013-11-23T00:00:00+08:00</updated>
   <id>http://lhzhang.com/2013/11/23/Find-the-centroid-of-the-hand-gestures</id>
   <content type="html">&lt;p&gt;For the next step, we need to find out the centroid of the hand. We employ two methods to this end, a simple one using all the points in the hand region, and another one called &lt;strong&gt;Distance Transform&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Because we know the points in the hand region have value 1 while others are 0. So we can easily use the points in the hand to calculate the centroid. Here is the code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function [x_center,y_center]=center_finder(edge_map,binary_map,x_array,y_array)
    %% ----find the center point, solution 1---- %%
    [y_binary,x_binary]=ind2sub(size(binary_map),find(binary_map));
    x_center=round(mean(x_binary));
    y_center=round(mean(y_binary));
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another method is called the &lt;strong&gt;Distance Transform&lt;/strong&gt;. You can refer to my other post to check out concept or the algorithm I developed. Here is the code of centroid finger using &lt;strong&gt;Distance Transform&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function [x_center,y_center]=center_finder(edge_map,binary_map,x_array,y_array)
    %% ----find the center point, solution 2---- %%
    max_distance=0;
    dist_trans_map=bwdist(edge_map);
    % dist_trans_map1=dist_trans(edge_map);    %distance transform I implement
    dist_trans_map(binary_map==0)=0;
    x_left=min(x_array(x_array~=0));
    x_right=max(x_array);
    y_up=min(y_array(y_array~=0));
    y_bottom=max(y_array);
    for i=x_left:x_right
        for j=y_up:y_bottom
            if(dist_trans_map(j,i)&amp;gt;max_distance)
                x_center=i;
                y_center=j;
                max_distance=dist_trans_map(j,i);
            end
        end
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the result and choose the latter methods.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Wifi-based classroom interaction system</title>
   <link href="http://lhzhang.com/2013/10/20/wifi-interaction-system.html"/>
   <updated>2013-10-20T00:00:00+08:00</updated>
   <id>http://lhzhang.com/2013/10/20/wifi-interaction-system</id>
   <content type="html">&lt;p&gt;In this project, we aimed to address the issue of lack of interaction between lecturers and students. With the help of our system, student can answer the multiple choice questions using the mobile app, the answers are dynamically changing according to the students' sending. Or students can send questions they don't understand to the PC program installed in the lecturers computer. The system requires no database or web server whatesoever, highly portable.&lt;/p&gt;

&lt;p&gt;[app][app] &amp;mdash; [code][code] &amp;mdash; [hn]&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>A MATLAB implementation of distance transform algorithm</title>
   <link href="http://lhzhang.com/2013/10/19/An-implementation-of-the-distance-transform-algorithm-using-MATLAB.html"/>
   <updated>2013-10-19T00:00:00+08:00</updated>
   <id>http://lhzhang.com/2013/10/19/An-implementation-of-the-distance-transform-algorithm-using-MATLAB</id>
   <content type="html">&lt;p&gt;In the gesture recognition algorithms we are developing, I need to calculate the transform distance of a binary image. Though the MATLAB has a function for just that purpose, I decided to dig around and find more efficient ways to implement this algorithm.&lt;/p&gt;

&lt;p&gt;For folks who are not familiar with distance transform, there is a great &lt;a href=&quot;http://homepages.inf.ed.ac.uk/rbf/HIPR2/distance.htm&quot;&gt;post&lt;/a&gt; for you. This can give a big picture of what this task is about.&lt;/p&gt;

&lt;p&gt;The algorithm I implement is using &lt;strong&gt;chessboard&lt;/strong&gt; distance metric. And I'm still working on some other metrics. For instance, &lt;strong&gt;Euclidean&lt;/strong&gt; and &lt;strong&gt;city block&lt;/strong&gt; metrics.&lt;/p&gt;

&lt;p&gt;First, we assume that the pixel value of the object is 1, and that of the background is 0. Then distance transform is defined as the smallest distance between the object and background pixels. And this value is used to replace the pixel value of the object.&lt;/p&gt;

&lt;h2&gt;Logic of the algorithm&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;direction: up-left to bottom-right
    for each pixel
    if the value is greater than 0 (namely, object pixel)
        get the pixels from the *left*, *up-left*, *up*, *up-right*   directions
        add 1 to the minimum value, assign it to the object pixel
    end if
end for

direction: bottom-right to up-left
    for each pixel
    if the value is greater than 0 (namely, object pixel)
        get the pixels from the *right*, *bottom-right*, *bottom*, *bottom-left* directions
        add 1 to the minimum value, assign it to the object pixel
    end if
end for
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the MATLAB code is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function dt=dist_trans(mat)
index0=(mat==0);
index1=(mat==1);
mat(index0)=1;
mat(index1)=0;

[y_index,x_index]=find(mat==0);
x_min=min(x_index);
x_max=max(x_index);
y_min=min(y_index);
y_max=max(y_index);
for n=1:10
for i=y_min:y_max
    for j=x_min:x_max
        if(mat(i,j)&amp;gt;0)
            if((i==1)&amp;amp;&amp;amp;(j==1));
            elseif(i==1)
                mat(i,j)=mat(i,j-1)+1;
            elseif(j==1)
                mat(i,j)=min([mat(i-1,j),mat(i-1,j+1)])+1;
            elseif(j==x_max)
                mat(i,j)=min([mat(i,j-1),mat(i-1,j-1),mat(i-1,j)])+1;
            else
                mat(i,j)=min([mat(i,j-1),mat(i-1,j-1),mat(i-1,j),mat(i-1,j+1)])+1;
            end
        end
    end
end

for i=y_max:-1:y_min
    for j=x_max:-1:x_min
        if(mat(i,j)&amp;gt;0)
            if((i==y_max)&amp;amp;&amp;amp;(j==x_max));
            elseif(i==y_max)
                mat(i,j)=min([mat(i,j),mat(i,j+1)+1]);
            elseif(j==x_max)
                mat(i,j)=min([mat(i,j),mat(i+1,j)+1,mat(i+1,j-1)+1]);
            elseif(j==1)
                mat(i,j)=min([mat(i,j),mat(i,j+1)+1,mat(i+1,j+1)+1,mat(i+1,j)+1]);
            else
                mat(i,j)=min([mat(i,j),mat(i,j+1)+1,mat(i+1,j+1)+1,mat(i+1,j)+1,mat(i+1,j-1)+1]);
            end
        end
    end
end
end
dt=mat;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The advantage of this algorithm is its simlicity and easy to understand. There are lots of research in improving this algorithm and I'm just started my own research. So I hope more sophisticated and faster algorithms can come up later.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>A weird error caused by jekyll</title>
   <link href="http://lhzhang.com/2013/10/19/A-weird-erroe-caused-by-jekyll.html"/>
   <updated>2013-10-19T00:00:00+08:00</updated>
   <id>http://lhzhang.com/2013/10/19/A-weird-erroe-caused-by-jekyll</id>
   <content type="html">&lt;p&gt;I haven't got the chance to update my blog for a while. When I did today and tried to run it locally in my machine, I ran into an error.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/images/jekyll%20error.png&quot; alt=&quot;jekyll_error&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I googled and found the solution. Because the default format of YAML is &lt;strong&gt;parameter+: +white space&lt;/strong&gt;, so if you happen to forget the white space, you gonna run into the same error as I did. So simple solution is adding the white space.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>放弃保研</title>
   <link href="http://lhzhang.com/2013/09/22/%E6%94%BE%E5%BC%83%E4%BF%9D%E7%A0%94.html"/>
   <updated>2013-09-22T00:00:00+08:00</updated>
   <id>http://lhzhang.com/2013/09/22/放弃保研</id>
   <content type="html">&lt;p&gt;今天早上还没睡醒，就要起床去签什么破协议。到了那里之后，没想到人会这么多，教务的效率未免有点低啊，不能分批去吗？我本来就不喜欢呆在人多的地方，只一心想着签完之后早点走掉。签字的时候感脚心里有点小波澜——一个是前途有保障的未来，一个则是完全未知，不知道能否成功，但是却为之努力了这么久的事情。但我觉得我还是做了正确的选择，与其选择一个自己不想要的安全的生活，在接下来的日子里过着吃薯片，看美剧的生活，我宁愿拼一把，冒一次险。即使失败了，大不了从头来过，哥们才21岁，有的是青春和时间来挥霍。No guts, no glory。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>电设总结</title>
   <link href="http://lhzhang.com/2013/09/21/%E7%94%B5%E8%AE%BE%E6%80%BB%E7%BB%93-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%E5%BC%80%E7%AB%AF%E7%AF%87.html"/>
   <updated>2013-09-21T00:00:00+08:00</updated>
   <id>http://lhzhang.com/2013/09/21/电设总结-技术总结开端篇</id>
   <content type="html">&lt;p&gt;这次电设学到了很多东西，虽然跟高手还有很大的差距，但比起自己刚开始的时候进步还是很大的。因为学了蛮多的技术，编了挺多的代码的，所以就把它们写在博客里，一来梳理一下学过的东东，而来供以后查找使用。这一篇blog就算给自己挖一个坑，日后一点一点的慢慢补。因为我觉得针对某一个具体的开发平台写的话太流水帐了，所以我只记录我认为比较有趣的点。&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
